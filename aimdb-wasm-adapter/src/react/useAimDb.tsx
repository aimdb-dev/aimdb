/**
 * React hooks for AimDB WASM integration.
 *
 * Drop-in hooks that subscribe to AimDB records backed by a local WASM
 * database instance with full Rust serde contract enforcement.
 *
 * @example
 * ```tsx
 * import { AimDbProvider, useRecord } from '@aimdb/wasm/react';
 *
 * function App() {
 *   return (
 *     <AimDbProvider config={{
 *       records: [
 *         { key: 'sensors.temperature.vienna', schemaType: 'temperature', buffer: 'SingleLatest' },
 *         { key: 'sensors.humidity.vienna',    schemaType: 'humidity',    buffer: 'SingleLatest' },
 *       ],
 *       // Optional: connect to server
 *       bridge: { url: 'wss://api.cloud.aimdb.dev/ws', subscribeTopics: ['sensors/#'] },
 *     }}>
 *       <Dashboard />
 *     </AimDbProvider>
 *   );
 * }
 *
 * function Dashboard() {
 *   const temp = useRecord<Temperature>('sensors.temperature.vienna');
 *   if (!temp) return <Skeleton />;
 *   return <span>{temp.celsius}°C</span>;
 * }
 * ```
 *
 * @module
 */

import {
    createContext,
    useCallback,
    useContext,
    useEffect,
    useRef,
    useState,
    type ReactNode,
} from "react";

// ── Types ────────────────────────────────────────────────────────────────

/** Re-export from the WASM module (generated by wasm-pack). */
import type { WasmDb, WsBridge } from "../pkg/aimdb_wasm_adapter";

/** Record configuration entry for the provider. */
export interface RecordConfig {
    /** AimDB record key (e.g. `"sensors.temperature.vienna"`). */
    key: string;
    /** Schema type name matching `SchemaType::NAME` (e.g. `"temperature"`). */
    schemaType: string;
    /** Buffer type — string shorthand or object with capacity. */
    buffer: string | { type: string; capacity?: number };
}

/** Optional WebSocket bridge configuration. */
export interface BridgeConfig {
    /** WebSocket endpoint (e.g. `"wss://api.example.com/ws"`). */
    url: string;
    /** MQTT-style topic patterns to subscribe to. */
    subscribeTopics?: string[];
    /** Auto-reconnect on disconnect (default: `true`). */
    autoReconnect?: boolean;
    /** Request snapshots on (re)connect (default: `true`). */
    lateJoin?: boolean;
}

/** Full provider configuration. */
export interface AimDbConfig {
    /** Records to register before building the database. */
    records: RecordConfig[];
    /** Optional WsBridge configuration for server sync. */
    bridge?: BridgeConfig;
}

// ── Context ──────────────────────────────────────────────────────────────

interface AimDbContextValue {
    db: WasmDb | null;
    bridge: WsBridge | null;
    ready: boolean;
}

const AimDbContext = createContext<AimDbContextValue>({
    db: null,
    bridge: null,
    ready: false,
});

// ── Provider ─────────────────────────────────────────────────────────────

interface AimDbProviderProps {
    config: AimDbConfig;
    /** Shown while the WASM module initializes and the DB builds. */
    fallback?: ReactNode;
    children: ReactNode;
}

/**
 * Initializes the WASM AimDB instance and makes it available to descendants.
 *
 * - Loads and initializes the WASM module (async).
 * - Calls `configureRecord()` for each entry in `config.records`.
 * - Calls `await db.build()`.
 * - Optionally opens a `WsBridge` via `db.connectBridge()`.
 * - Renders `children` once the database is ready.
 */
export function AimDbProvider({
    config,
    fallback,
    children,
}: AimDbProviderProps) {
    const [ctx, setCtx] = useState<AimDbContextValue>({
        db: null,
        bridge: null,
        ready: false,
    });

    // Refs so the cleanup closure always sees the latest handles
    // (avoids the stale-closure bug where cleanup captures initial null state).
    const dbRef = useRef<WasmDb | null>(null);
    const bridgeRef = useRef<WsBridge | null>(null);

    useEffect(() => {
        let cancelled = false;

        (async () => {
            // Dynamic import so the WASM module is only loaded when the provider
            // mounts. Tree-shaking removes this path entirely if unused.
            const wasm = await import("../pkg/aimdb_wasm_adapter");

            // Initialize the WASM binary (required by wasm-pack --target web
            // before any constructors can be used). Idempotent on re-mount.
            await wasm.default();
            if (cancelled) return;

            const db = new wasm.WasmDb();

            // Configure all records
            for (const rec of config.records) {
                db.configureRecord(rec.key, {
                    schemaType: rec.schemaType,
                    buffer: rec.buffer,
                });
            }

            // Build the database (runs type registration, buffer allocation, etc.)
            await db.build();
            if (cancelled) return;

            dbRef.current = db;

            // Optionally connect WsBridge (db.connectBridge borrows — db stays valid)
            let bridge: WsBridge | null = null;
            if (config.bridge) {
                bridge = db.connectBridge(config.bridge.url, {
                    subscribeTopics: config.bridge.subscribeTopics ?? [],
                    autoReconnect: config.bridge.autoReconnect ?? true,
                    lateJoin: config.bridge.lateJoin ?? true,
                });
                bridgeRef.current = bridge;
            }

            setCtx({ db, bridge, ready: true });
        })();

        return () => {
            cancelled = true;
            // Cleanup uses refs — always sees the latest handles
            if (bridgeRef.current) {
                bridgeRef.current.disconnect();
                bridgeRef.current = null;
            }
            if (dbRef.current) {
                dbRef.current.free();
                dbRef.current = null;
            }
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    if (!ctx.ready) return <>{fallback ?? null}</>;

    return <AimDbContext.Provider value={ctx}>{children}</AimDbContext.Provider>;
}

// ── Hooks ────────────────────────────────────────────────────────────────

/**
 * Subscribe to an AimDB record by its key.
 *
 * Returns the latest validated value (deserialized by Rust serde in WASM)
 * or `null` if no value has been produced yet. Re-renders on every buffer
 * push.
 *
 * @typeParam T - The TypeScript shape of the record (e.g. `Temperature`).
 * @param recordKey - The AimDB record key (e.g. `"sensors.temperature.vienna"`).
 *
 * @example
 * ```tsx
 * interface Temperature { celsius: number; timestamp: number }
 *
 * function TempCard({ city }: { city: string }) {
 *   const temp = useRecord<Temperature>(`sensors.temperature.${city}`);
 *   if (!temp) return <Skeleton />;
 *   return <span>{temp.celsius.toFixed(1)}°C</span>;
 * }
 * ```
 */
export function useRecord<T>(recordKey: string): T | null {
    const { db, ready } = useContext(AimDbContext);
    const [value, setValue] = useState<T | null>(null);

    useEffect(() => {
        if (!ready || !db) return;

        // Seed with current value (if available)
        try {
            const current = db.get(recordKey) as T | undefined;
            if (current !== undefined) setValue(current);
        } catch {
            // Record may not have a value yet — that's fine
        }

        // Subscribe for live updates
        const unsub = db.subscribe(recordKey, (v: T) => setValue(v));

        return () => {
            if (typeof unsub === "function") unsub();
        };
    }, [db, ready, recordKey]);

    return value;
}

/**
 * Write a value to an AimDB record.
 *
 * Returns a setter function that validates the payload through Rust serde.
 * Throws if contract validation fails (missing fields, wrong types, etc.).
 *
 * @typeParam T - The TypeScript shape of the record.
 * @param recordKey - The AimDB record key.
 *
 * @example
 * ```tsx
 * const setTarget = useSetRecord<Setpoint>('commands.setpoint.room1');
 * setTarget({ target_celsius: 21.0, timestamp: Date.now() });
 * ```
 */
export function useSetRecord<T>(recordKey: string): (value: T) => void {
    const { db, ready } = useContext(AimDbContext);

    return useCallback(
        (value: T) => {
            if (!ready || !db) {
                throw new Error(
                    "AimDB not ready. Wrap your app in <AimDbProvider>.",
                );
            }
            db.set(recordKey, value);
        },
        [db, ready, recordKey],
    );
}

/**
 * Access the raw `WasmDb` instance for advanced operations.
 *
 * Prefer `useRecord` / `useSetRecord` for standard use cases.
 */
export function useAimDb(): WasmDb | null {
    return useContext(AimDbContext).db;
}

/**
 * Access the `WsBridge` instance for connection status monitoring.
 *
 * Returns `null` if no bridge was configured or the DB is not ready.
 *
 * @example
 * ```tsx
 * function ConnectionIndicator() {
 *   const bridge = useBridge();
 *   const [status, setStatus] = useState('connecting');
 *   useEffect(() => {
 *     bridge?.onStatusChange(setStatus);
 *   }, [bridge]);
 *   return <Badge>{status}</Badge>;
 * }
 * ```
 */
export function useBridge(): WsBridge | null {
    return useContext(AimDbContext).bridge;
}
