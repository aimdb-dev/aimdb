# Design: RecordKey Hash Implementation

**Status**: Phase 1 Complete, Phase 2 Deferred  
**Author**: Architecture Discussion  
**Date**: 2024-12-24  
**Updated**: 2024-12-25  
**Related**: [016-M6-record-key-trait.md](016-M6-record-key-trait.md)

## Implementation Status

| Phase | Description | Status |
|-------|-------------|--------|
| Phase 1 | Fix Hash in derive macro | ✅ Complete |
| Phase 2 | Propagate K generic throughout codebase | ⏸️ Deferred - No Current Use Case |

## Summary

The `RecordKey` derive macro should generate a `Hash` implementation that hashes the string key value, ensuring compliance with Rust's `Borrow` trait contract.

## Problem Statement

The `RecordKey` trait currently requires `Borrow<str>`:

```rust
pub trait RecordKey:
    Clone + Eq + core::hash::Hash + core::borrow::Borrow<str> + Send + Sync + 'static
{
    fn as_str(&self) -> &str;
}
```

The derive macro usage pattern is:

```rust
#[derive(RecordKey, Clone, Copy, PartialEq, Eq, Hash)]
pub enum AppKey {
    #[key = "temp.indoor"]
    TempIndoor,
    #[key = "temp.outdoor"]
    TempOutdoor,
}
```

**The Problem**: `#[derive(Hash)]` hashes the enum discriminant (0, 1), while `Borrow<str>` returns the string key. This violates Rust's `Borrow` trait contract.

### Borrow Trait Contract

From the [Rust documentation](https://doc.rust-lang.org/std/borrow/trait.Borrow.html):

> If you implement `Borrow<T>` for a type, the implementations of `Hash`, `Eq`, and `Ord` for `T` must be equivalent to those of the borrowed form.

Specifically:
```rust
// For K: Borrow<Q>, these must produce the same hash:
hash(k) == hash(k.borrow())
```

### Current Violation

```rust
use std::hash::{Hash, Hasher, DefaultHasher};
use std::borrow::Borrow;

fn hash<T: Hash>(t: &T) -> u64 {
    let mut h = DefaultHasher::new();
    t.hash(&mut h);
    h.finish()
}

let key = AppKey::TempIndoor;
let borrowed: &str = key.borrow();  // "temp.indoor"

// These MUST be equal per Borrow contract, but they're NOT:
hash(&key)      // Hashes discriminant 0 → e.g., 15130871412783076140
hash(&borrowed) // Hashes "temp.indoor" → e.g., 8726552997374857231
```

### Why This Matters

1. **HashMap Lookup Failure**: If someone creates `HashMap<AppKey, V>` and tries to look up by `&str`, it will fail:
   ```rust
   let mut map: HashMap<AppKey, i32> = HashMap::new();
   map.insert(AppKey::TempIndoor, 42);
   
   // This lookup will FAIL even though Borrow<str> is implemented:
   map.get("temp.indoor")  // Returns None! Different hash bucket.
   ```

2. **Semantic Violation**: The code compiles but silently does the wrong thing.

3. **Future Bugs**: The current implementation happens to work because `AimDbInner::resolve()` explicitly calls `key.as_str()` before lookup. But this is fragile and non-obvious.

## Current State

### AimDbInner Implementation (Works by Accident)

```rust
impl AimDbInner {
    pub fn resolve<K: RecordKey>(&self, key: &K) -> Option<RecordId> {
        // Works because we explicitly convert to string first
        self.by_key.get(key.as_str()).copied()
    }
}
```

This sidesteps the issue by never using the enum key directly in HashMap lookups.

### Why We Have Borrow<str> Bound

The `Borrow<str>` bound was added to enable:
1. O(1) string lookups for remote access (`resolve_str("name")`)
2. HashMap operations without allocating a key

However, since we store `StringKey` internally (not `K`), the bound is only used for the trait's semantic guarantee, not for actual lookups.

## Proposed Solution

### Option A: Generate Hash in Derive Macro (Recommended)

The derive macro generates a `Hash` impl that hashes `as_str()`:

```rust
// Generated by #[derive(RecordKey)]
impl core::hash::Hash for AppKey {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        <Self as aimdb_core::RecordKey>::as_str(self).hash(state);
    }
}
```

**User code changes:**
```rust
// Before (problematic)
#[derive(RecordKey, Clone, Copy, PartialEq, Eq, Hash)]

// After (correct)
#[derive(RecordKey, Clone, Copy, PartialEq, Eq)]  // Hash is auto-generated
```

**Pros:**
- Correct by construction - impossible to violate Borrow contract
- Users don't need to understand the Hash/Borrow interaction
- Compile error if user also derives Hash (duplicate impl)

**Cons:**
- Slightly more complex macro
- Breaking change for existing code that derives Hash

### Option B: Remove Borrow<str> from Trait

```rust
pub trait RecordKey:
    Clone + Eq + core::hash::Hash + Send + Sync + 'static
{
    fn as_str(&self) -> &str;
}
```

**Pros:**
- No Hash/Borrow contract to violate
- Simpler mental model

**Cons:**
- Loses semantic intent (keys are string-representable)
- Requires explicit `.as_str()` everywhere (already the case)
- May limit future HashMap optimizations

### Option C: Document "Don't Derive Hash"

Keep current design, add compile-time warning or documentation.

**Pros:**
- No code changes

**Cons:**
- Easy to get wrong
- Violates principle of "make invalid states unrepresentable"
- Latent bugs waiting to happen

## Recommendation

**Option A: Generate Hash in Derive Macro**

This follows Rust's philosophy of correctness by construction. The derive macro already generates `Borrow<str>`, so generating `Hash` for consistency is natural.

## Implementation Plan

### Phase 1: Update Derive Macro

```rust
// aimdb-derive/src/lib.rs

let expanded = quote! {
    impl aimdb_core::RecordKey for #name {
        #[inline]
        fn as_str(&self) -> &str {
            match self {
                #(#as_str_arms),*
            }
        }

        #link_impl
    }

    impl core::borrow::Borrow<str> for #name {
        #[inline]
        fn borrow(&self) -> &str {
            <Self as aimdb_core::RecordKey>::as_str(self)
        }
    }

    // NEW: Generate Hash that hashes the string key
    impl core::hash::Hash for #name {
        fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
            <Self as aimdb_core::RecordKey>::as_str(self).hash(state);
        }
    }
};
```

### Phase 2: Update Examples and Documentation

Remove `Hash` from derive lists in all examples:

```rust
// Before
#[derive(RecordKey, Clone, Copy, PartialEq, Eq, Hash, Debug)]

// After  
#[derive(RecordKey, Clone, Copy, PartialEq, Eq, Debug)]
```

### Phase 3: Update Design Document

Update `016-M6-record-key-trait.md` to reflect this decision.

### Phase 4: Add Tests

Add tests verifying hash consistency:

```rust
#[test]
fn test_record_key_hash_borrow_consistency() {
    use std::hash::{Hash, Hasher, DefaultHasher};
    use std::borrow::Borrow;

    fn hash_value<T: Hash>(t: &T) -> u64 {
        let mut h = DefaultHasher::new();
        t.hash(&mut h);
        h.finish()
    }

    let key = SensorKey::TempIndoor;
    let borrowed: &str = key.borrow();

    // These MUST be equal per Borrow contract
    assert_eq!(hash_value(&key), hash_value(&borrowed));
}

#[test]
fn test_hashmap_lookup_by_str() {
    use std::collections::HashMap;

    let mut map: HashMap<SensorKey, i32> = HashMap::new();
    map.insert(SensorKey::TempIndoor, 42);

    // This should work correctly with our Hash impl
    assert_eq!(map.get("sensor.temp.indoor"), Some(&42));
}
```

## Migration Impact

### Breaking Changes

Users who have:
```rust
#[derive(RecordKey, Hash, ...)]
```

Will get a compile error:
```
error[E0119]: conflicting implementations of trait `Hash` for type `AppKey`
```

**Fix**: Remove `Hash` from the derive list.

### Non-Breaking for New Users

New users will naturally write:
```rust
#[derive(RecordKey, Clone, Copy, PartialEq, Eq)]
```

And get correct behavior automatically.

## Alternatives Considered

### Generate PartialEq/Eq Too?

We could also generate `PartialEq` and `Eq` based on string comparison. However:

- For unique keys, discriminant comparison (`derive(PartialEq)`) is equivalent
- Discriminant comparison is faster (single integer compare vs string compare)
- No Borrow contract requirement for Eq

**Decision**: Keep user-derived `PartialEq`/`Eq`.

### Warn at Compile Time if Hash is Derived?

We could detect `#[derive(Hash)]` and emit a warning. However:

- Complex to implement in proc-macro (limited visibility into other derives)
- Duplicate impl error is clear enough

**Decision**: Rely on duplicate impl error.

## Open Questions

1. **Should we generate `Ord`/`PartialOrd` too?**
   
   The Borrow contract also mentions `Ord`. If users derive `Ord`, it should order by discriminant, but `Borrow<str>` implies string ordering. For now, we don't generate these - users who need ordering can implement manually or accept discriminant ordering.

2. **Performance impact of string hashing?**
   
   String hashing is slightly slower than discriminant hashing, but:
   - Keys are typically short (< 50 chars)
   - HashMap operations are control-plane, not hot-path
   - Correctness > micro-optimization

## Decision

Proceed with **Option A**: Generate `Hash` implementation in the derive macro.

---

## Related: Use RecordKey Throughout Codebase

### Current State

Several internal types store `String` instead of the generic key type `K`:

```rust
// Current implementation
pub struct Producer<T, R: Spawn + 'static> {
    db: Arc<AimDb<R>>,
    record_key: String,  // ❌ Always String, loses type info
    _phantom: PhantomData<T>,
}

pub struct Consumer<T, R: Spawn + 'static> {
    db: Arc<AimDb<R>>,
    record_key: String,  // ❌ Always String
    _phantom: PhantomData<T>,
}

pub struct RecordRegistrar<'a, T, R> {
    pub(crate) rec: &'a mut TypedRecord<T, R>,
    pub(crate) connector_builders: &'a [Box<dyn ConnectorBuilder<R>>],
    pub(crate) record_key: String,  // ❌ Always String
}
```

### Problem

1. **Memory overhead on embedded**: `String` requires heap allocation even for enum keys
2. **Lost type information**: Enum key benefits (exhaustiveness, IDE support) stop at API boundary
3. **Inconsistent API**: Users pass `K`, internals use `String`

### Recommended Approach

Propagate `K: RecordKey` through the type system:

```rust
// Recommended implementation
pub struct Producer<T, R, K = StringKey>
where
    R: Spawn + 'static,
    K: RecordKey,
{
    db: Arc<AimDb<R, K>>,
    record_key: K,  // ✅ Generic, zero-alloc for Copy enums
    _phantom: PhantomData<T>,
}

pub struct Consumer<T, R, K = StringKey>
where
    R: Spawn + 'static,
    K: RecordKey,
{
    db: Arc<AimDb<R, K>>,
    record_key: K,  // ✅ Generic
    _phantom: PhantomData<T>,
}

pub struct AimDb<R, K = StringKey>
where
    R: Spawn + 'static,
    K: RecordKey,
{
    inner: Arc<AimDbInner<K>>,
    runtime: Arc<R>,
}

pub struct AimDbInner<K: RecordKey = StringKey> {
    by_key: HashMap<K, RecordId>,  // ✅ Generic key type
    // ...
}
```

### Benefits

| Aspect | String (Current) | Generic K (Proposed) |
|--------|------------------|---------------------|
| Embedded memory | Heap allocation | Zero-copy for `Copy` enums |
| Type safety | Lost at boundary | Preserved throughout |
| API consistency | Mixed | Uniform |
| Default behavior | Same | Same (`K = StringKey`) |

### Implementation Scope

This is a larger refactor than the Hash fix. Recommended phasing:

1. **Phase 1 (This PR)**: Fix Hash in derive macro (immediate correctness fix)
2. **Phase 2 (Future PR)**: Propagate `K` generic through:
   - `AimDb<R>` → `AimDb<R, K = StringKey>`
   - `AimDbInner` → `AimDbInner<K = StringKey>`
   - `AimDbBuilder<R>` → `AimDbBuilder<R, K = StringKey>`
   - `Producer<T, R>` → `Producer<T, R, K = StringKey>`
   - `Consumer<T, R>` → `Consumer<T, R, K = StringKey>`
   - `RecordRegistrar<'a, T, R>` → `RecordRegistrar<'a, T, R, K = StringKey>`

### Migration Path

With `K = StringKey` defaults, existing code continues to work:

```rust
// Existing code (unchanged)
let db: AimDb<TokioAdapter> = builder.build()?;  // K defaults to StringKey

// New embedded code (explicit K)
let db: AimDb<EmbassyAdapter, AppKey> = builder.build()?;
```

### Files Requiring Changes (Phase 2)

| File | Change |
|------|--------|
| `aimdb-core/src/builder.rs` | Add `K` generic to `AimDb`, `AimDbInner`, `AimDbBuilder` |
| `aimdb-core/src/typed_api.rs` | Add `K` generic to `Producer`, `Consumer`, `RecordRegistrar` |
| `aimdb-core/src/database.rs` | Add `K` generic to `Database` wrapper |
| `aimdb-core/src/typed_record.rs` | Update key storage |
| `aimdb-core/src/ext_macros.rs` | Update macro to propagate `K` |
| `aimdb-tokio-adapter/src/lib.rs` | Update extension traits |
| `aimdb-embassy-adapter/src/lib.rs` | Update extension traits |

---

## Phase 2 Implementation Roadblocks

> **Status**: Phase 2 analyzed on 2024-12-25. Deferred due to lack of concrete use case, not fundamental impossibility.

### Analysis Summary

The roadblocks below are **engineering challenges, not fundamental impossibilities**. Full `K` propagation is estimated at 3-4 weeks of work with breaking API changes. However, without a concrete embedded use case requiring zero-allocation keys, the effort is not justified.

### The Core Problem

The `K` generic cannot propagate cleanly through the type system due to **type erasure boundaries** in the task spawning architecture.

### Roadblock 1: TypedRecord Closure Signatures

`TypedRecord<T, R>` stores producer/consumer service closures with fixed signatures:

```rust
// aimdb-core/src/typed_record.rs
type ProducerServiceFn<T, R> = Box<
    dyn FnOnce(Producer<T, R>, RuntimeContext<R>) -> Pin<Box<dyn Future<...>>> + Send
>;

type ConsumerServiceFn<T, R> = Box<
    dyn FnOnce(Consumer<T, R>) -> Pin<Box<dyn Future<...>>> + Send
>;
```

These closures expect `Producer<T, R>` (with implicit `K = StringKey`). Making these K-generic would require:

```rust
// Would require this change:
pub struct TypedRecord<T, R, K: RecordKey = StringKey> {
    producer_service: Option<ProducerServiceFn<T, R, K>>,
    consumer_tasks: Vec<ConsumerServiceFn<T, R, K>>,
    // ...
}
```

**Impact**: This change cascades through the entire `TypedRecord` API, affecting:
- `RecordRegistrar::source_raw()`
- `RecordRegistrar::tap_raw()`
- All extension macros that generate service closures
- The `AnyRecord` trait and downcasting logic

### Roadblock 2: Type Erasure in Spawn Functions

Spawn functions are stored as `Box<dyn Any>` for type erasure:

```rust
// aimdb-core/src/builder.rs
spawn_fns: Vec<(K, Box<dyn Any + Send>)>,

// At build time:
type SpawnFnType<R, K> = Box<
    dyn FnOnce(&Arc<R>, &Arc<AimDb<R, K>>, RecordId) -> DbResult<()> + Send
>;

let spawn_fn = spawn_fn_any
    .downcast::<SpawnFnType<R, K>>()  // Requires exact type match!
    .expect("spawn function type mismatch");
```

The downcast requires **exact type matching**. `SpawnFnType<R, AppKey>` and `SpawnFnType<R, StringKey>` are incompatible types, even though they're functionally equivalent.

### Roadblock 3: Cross-Boundary Type Incompatibility

At spawn time, we have `Arc<AimDb<R, K>>`, but closures stored in `TypedRecord` expect `Producer<T, R>` which internally stores `Arc<AimDb<R, StringKey>>`:

```rust
// TypedRecord closure expects:
fn service(producer: Producer<T, R>, ctx: RuntimeContext<R>) -> impl Future<...>
//                          ^-- Producer<T, R, StringKey>

// But spawn_producer_service receives:
fn spawn_producer_service(&self, db: &Arc<AimDb<R, K>>, ...)
//                                          ^-- AimDb<R, K> where K != StringKey
```

`Producer::new()` requires `Arc<AimDb<R, K>>` to match its internal storage type. There's no safe way to convert between `AimDb<R, AppKey>` and `AimDb<R, StringKey>`.

### Attempted Solutions

| Approach | Problem |
|----------|---------|
| Make `TypedRecord<T, R, K>` | Too invasive; cascades through all APIs |
| Use `unsafe` transmute | Undefined behavior; different generic instantiations may have different layouts |
| Store trait object `Arc<dyn DbOps>` in Producer | Async trait methods complicate this; adds overhead |
| Convert K→StringKey at boundary | Loses the zero-allocation benefit for embedded |

### Why Phase 1 Is Sufficient

Phase 1 (the Hash fix) already provides the **core correctness guarantee**:

1. **HashMap lookups work correctly**: `map.get("key.name")` now works on `HashMap<K, V>` where `K: RecordKey`
2. **Borrow contract satisfied**: `hash(key) == hash(key.borrow())`
3. **No silent bugs**: The Hash/Borrow violation that could cause lookup failures is fixed

The internal use of `String`/`StringKey` doesn't violate correctness—it's a **memory optimization opportunity**, not a correctness issue.

### Future Considerations

If embedded memory optimization becomes necessary, there are three approaches with different trade-offs:

#### Option A: SmallKey Pattern (Recommended for Embedded)

Replace internal `String` storage with a stack-allocated small-string type:

```rust
/// Stack-allocated key for strings ≤ 31 bytes (covers 99% of real keys)
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct SmallKey {
    data: [u8; 31],  // Inline storage (no heap allocation)
    len: u8,         // Actual length (max 31)
}

impl SmallKey {
    pub fn new(s: &str) -> Option<Self> {
        if s.len() > 31 { return None; }
        let mut data = [0u8; 31];
        data[..s.len()].copy_from_slice(s.as_bytes());
        Some(Self { data, len: s.len() as u8 })
    }
    
    pub fn as_str(&self) -> &str {
        // SAFETY: We only store valid UTF-8 from &str input
        unsafe { core::str::from_utf8_unchecked(&self.data[..self.len as usize]) }
    }
}
```

**Benefits:**
- ✅ Zero heap allocation for keys ≤ 31 bytes (covers most real-world keys)
- ✅ Works without `alloc` feature for no_std
- ✅ **Non-breaking change** - internal only, API unchanged
- ✅ ~1 week implementation effort

**Limitations:**
- ❌ Keys > 31 bytes need fallback or error
- ❌ Doesn't preserve compile-time enum exhaustiveness at lookup boundaries

**User-facing impact: None** - This is purely an internal optimization:

```rust
// User code stays EXACTLY the same
#[derive(RecordKey, Clone, Copy, PartialEq, Eq)]
pub enum SensorKey {
    #[key = "sensor.temp.indoor"]
    TempIndoor,
}

// Registration unchanged
builder.configure::<Temperature>(SensorKey::TempIndoor, |reg| {
    reg.buffer(...)
       .source(temperature_service)
       .tap(logger_service);
});

// Producer/Consumer usage unchanged
async fn temperature_service(ctx: RuntimeContext, producer: Producer<Temperature>) {
    producer.produce(Temperature { celsius: 22.5 }).await?;
}
```

#### Option B: Full K Generic Propagation

Propagate `K: RecordKey` through all types (`AimDb<R, K>`, `Producer<T, R, K>`, etc.).

**Benefits:**
- ✅ Zero-copy for `Copy` enum keys
- ✅ Type information preserved throughout
- ✅ Enables exhaustive matching on `producer.key()`

**Costs:**
- ❌ ~3-4 weeks implementation effort
- ❌ Breaking API change (major version bump)
- ❌ Every struct gains `K = StringKey` parameter
- ❌ More complex type signatures

#### Option C: Key Interning

Use a global key registry with integer IDs instead of string storage.

**Benefits:**
- ✅ Minimal memory per key (just an integer)
- ✅ O(1) comparisons

**Costs:**
- ❌ Requires global state or context passing
- ❌ Complex lifetime management
- ❌ Not suitable for no_std without careful design

### Decision

**Current recommendation**: Keep Phase 1 (Hash fix) and defer Phase 2 indefinitely.

**If embedded memory becomes critical**: Implement Option A (SmallKey) first. It provides 80% of the benefit for 20% of the cost, with no breaking changes.

**If full type preservation is needed**: Consider Option B, but only with a concrete use case and willingness to accept a major version bump.

---

## Appendix: Full Generated Code Example

For this input:
```rust
#[derive(RecordKey, Clone, Copy, PartialEq, Eq, Debug)]
#[key_prefix = "sensor."]
pub enum SensorKey {
    #[key = "temp.indoor"]
    #[link_address = "mqtt://sensors/temp/indoor"]
    TempIndoor,
    
    #[key = "temp.outdoor"]
    TempOutdoor,
}
```

The macro generates:
```rust
impl aimdb_core::RecordKey for SensorKey {
    #[inline]
    fn as_str(&self) -> &str {
        match self {
            Self::TempIndoor => "sensor.temp.indoor",
            Self::TempOutdoor => "sensor.temp.outdoor",
        }
    }

    #[inline]
    fn link_address(&self) -> Option<&str> {
        match self {
            Self::TempIndoor => Some("mqtt://sensors/temp/indoor"),
            Self::TempOutdoor => None,
        }
    }
}

impl core::borrow::Borrow<str> for SensorKey {
    #[inline]
    fn borrow(&self) -> &str {
        <Self as aimdb_core::RecordKey>::as_str(self)
    }
}

impl core::hash::Hash for SensorKey {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        <Self as aimdb_core::RecordKey>::as_str(self).hash(state);
    }
}
```
